import inspect
import types

from command import DummyCommand
from interface.movable import IMovable, Vector
from ioc.ioc_container import IOC_COMMAND, IoC
from utils import adapter_key

_adapter_class_cache = {}


# Генератор адаптеров
def generate_adapter(interface_cls):
    # Проверяем — не создавали ли уже для этого интерфейса
    if interface_cls in _adapter_class_cache:
        return _adapter_class_cache[interface_cls]

    print(f"[Adapter Generator] Generating adapter for {interface_cls.__name__}")

    class_name = f"AutoGenerated{interface_cls.__name__}Adapter"

    def make_getter_method(prop_name):
        def getter(self):
            return IoC.resolve(
                f"{interface_cls.__module__}.{interface_cls.__name__}:{prop_name}.get",
                self._obj,
            )

        return getter

    def make_setter_method(prop_name):
        def setter(self, new_value):
            IoC.resolve(
                f"{interface_cls.__module__}.{interface_cls.__name__}:{prop_name}.set",
                self._obj,
                new_value,
            ).execute()

        return setter

    def make_command_method(method_name):
        def method(self, *args, **kwargs):
            command = IoC.resolve(
                f"{interface_cls.__module__}.{interface_cls.__name__}:{method_name}",
                self._obj,
                *args,
                **kwargs,
            )
            # Если результат — команда с execute(), вызываем её
            if hasattr(command, "execute") and callable(command.execute):
                return command.execute()
            else:
                return command

        return method

    methods = {}

    for name, member in inspect.getmembers(interface_cls, predicate=inspect.isfunction):
        if name.startswith("get_"):
            prop_name = name[4:]
            methods[name] = make_getter_method(prop_name)
        elif name.startswith("set_"):
            prop_name = name[4:]
            methods[name] = make_setter_method(prop_name)
        else:
            # произвольные методы
            methods[name] = make_command_method(name)

    def __init__(self, obj):
        self._obj = obj

    methods["__init__"] = __init__

    adapter_cls = types.new_class(
        class_name, (interface_cls,), exec_body=lambda ns: ns.update(methods)
    )

    # Сохраняем в кэш
    _adapter_class_cache[interface_cls] = adapter_cls

    return adapter_cls


# Регистрация стратегии "adapter" в IoC
def adapter_factory(args):
    interface_cls, obj = args
    adapter_cls = generate_adapter(interface_cls)
    return adapter_cls(obj)


IoC.resolve(IOC_COMMAND.REGISTER.value, "adapter", adapter_factory)

IoC.resolve(
    IOC_COMMAND.REGISTER.value,
    adapter_key(IMovable, "position", "get"),
    lambda args: Vector(10, 20),
)

IoC.resolve(
    IOC_COMMAND.REGISTER.value,
    adapter_key(IMovable, "velocity", "get"),
    lambda args: Vector(5, 5),
)

IoC.resolve(
    IOC_COMMAND.REGISTER.value,
    adapter_key(IMovable, "position", "set"),
    lambda args: DummyCommand(*args),
)

IoC.resolve(
    IOC_COMMAND.REGISTER.value,
    adapter_key(IMovable, "finish", ""),
    lambda args: DummyCommand(*args),
)
