# ДЗ 19. Написать Endpoint для приема входящих сообщений
## Термины
**Игровой сервер** - это приложение, на котором вычисляется состояние космических боев, то есть выполняются все те команды, которые рассматривались на предыдущих занятиях.
**Агент** - это специальное приложение, на котором игрок запускает свой алгоритм управления своей командой кораблей.
Для полноценной реализации игры необходимо обеспечить двусторонний обмен данными между Игровым сервером и Агентами. Частью такого обмена будет Endpoint для приема входящих сообщений Игорвым сервером.
В результате выполнения ДЗ будет получен код, основанный на паттернах системы обмена сообщениями для приема входящих сообщений от Агентов.
**Цель** - применить навыки построения архитектуры, основанной на системе обмена сообщениями.
## Описание/Пошаговая инструкция выполнения домашнего задания:
Задача Endpoint принять входящее сообщение от Агента, десериализовать его и передать его на обработку внутрь игрового сервера.
Прием входящих сообщений и их десериализацию скорее всего возьмут на себя те библиотеки, которыми Вы будете пользоваться.
А вот определить какому из космических боев это сообщение было адресовано (маршрутизация) и его уведомление о входящем сообщении (передача сообщения в обработку) - это то, что придется делать в рамках этого ДЗ.
Организовать Endpoint можно реализовать разными способами. Здесь выбирайте тот, который считаете полезным для своих прикладных задач на работе, а не для данной игры.
Ну или тот, с которым сами бы хотели разобраться. Ниже приведены разные варианты, что можно было бы сделать:
- Endpoint поверх Tcp/IP или UDP протокола.
- Controller в web-фреймворке.
- Endpoint на основе веб-сокетов.
- Rest
- Подписка на получение сообщений из какого-нибудь Message Broker'а.
- Выбор варианта не сильно отразится на остальной архитектуре, то есть концептуально будет одно и тоже, а вот у каждого варианта могут быть свои ньюансы реализации, поэтому степень полезности того или иного способа реализации прямо зависит от того, в какую сторону лично Вы хотите развиваться.
## Шаги выполнения ДЗ:
1. Определить формат сообщений, которые отправляет Агент игровому серверу.
Указание: правила во всех играх могут сильно отличаться друг от друга, поэтому нужно подумать о таком формате, который бы не зависел от текущей реализации конкретных команд, то есть чтобы endpoint не приходилось модифицировать каждый раз, когда мы разработаем новое правило игры. Как идею для решения поставленной задачи можно рассмотреть следующий набор данных, который стоит передавать в сообщении:
 - id игры - для идентификации игры, в рамках которой это сообщение обработано. С помощью этого id можно будет определить получателя сообщения при маршрутизации сообщения внутри игрового сервера.
 - id игрового объекта, которому адресовано сообщение. С помощью этого id можно будет определить игровой объект внутри игры, для которого адресовано это сообщение.
 - id операции - по этому id в IoC можно будет определить команду, которая будет обрабатывать данное сообщение.
 - args - вложенный json объект с параметрами операции. Содержимое этого объекта полностью зависит от команды, которая будет применяться к игровому объекту.
2. Определить endpoint, который принимает входящее сообщение и конвертирует в команду InterpretCommand.
enpoint должен определить игру, которой адресовано сообщение, создать команду InterpretCommand и поместить эту команду в очередь команд этой игры.
Команда InterpretCommand получает всю информацию об операции, которую необходимо выполнить, параметрах и объекте, над которым эта операция будет выполняться.
Задача команды InetrpretCommand на основе IoC контейнера создать команду для нужного объекта, которая которая соответствует приказу, содержащемуся в сообщении и постановки этой команды в очередь команд игры.
Например, если сообщение указано, что объект с id 548 должен начать двигаться, то результат InterpretCommand заключается можно описать следующим псевдокодом
```
var obj = IoC.Resolve("Игровые объекты", "548"); // "548" получено из входящего сообщения
IoC.Resolve("Установить начальное значение скорости", obj, 2); // значение 2 получено из args переданного в сообщении
var cmd = IoC.Resolve("Движение по прямой", obj); // Решение, что нужно выполнить движение по прямой получено из сообщения
// обратите внимание само значение "Движение по прямой" нельзя читать на прямую из сообщения,
// чтобы избежать инъекции, когда пользователь попытается выполнить действие, которое ему выполнять не позволено
IoC.Resolve("Очередь команд", cmd).Execute(); // Выполняем команду, которая поместит команду cmd в очередь команд игры.
```
Дополнительно:
Можно реализовать двусторонний обмен данными между Игровым сервером и Агентом. Так как для принятия решения о той или иной операции на Агенте необходимо знать текущее состояние космической битвы. Для этого можно использовать websocket или tcp/ip или любой другой способ. С точки зрения игры это выглядит так - есть команда, при выполнении которой она сериализует состояние игровых объектов и инициирует процесс отправки этих данных на Агент. Далее рассылка сохраненного состояния производится через реализованный двусторонний обмен данными.

- [x] Описан формат сообщения. формат сообщения универсален и удовлетворяет SOLID (принимается, если преподаватель может придумать контрпример, который приводит к изменению формата)
- [x] Реализован endpoint, который вычисляет игру и ставит команду в очередь игры
- [x] Реализована Interpret Command


# ДЗ 17. Многопоточное выполнение команд
Предположим, что у нас есть набор команд, которые необходимо выполнить. Выполнение команд организуем в несколько потоков.
Для этого будем считать, что у каждого потока есть своя потокобезопасная очередь.
Для того, чтобы выполнить команду, ее необходимо добавить в очередь. Поток читает очередную команду из очереди и выполняет ее.
Если выполнение команды прерывается выброшенным исключением, то поток должен отловить его и продолжить работу.
Если сообщений нет в очереди, то поток засыпает до тех пор, пока очередь пуста.

Последовательность шагов решения:

- [x] Реализовать код, который запускается в отдельном потоке и делает следующее
- [x] В цикле получает из потокобезопасной очереди команду и запускает ее.
- [x] Выброс исключения из команды не должен прерывать выполнение потока.
- [x] Написать команду, которая стартует код, написанный в пункте 1 в отдельном потоке.
- [x] Написать команду, которая останавливает цикл выполнения команд из пункта 1, не дожидаясь их полного завершения (hard stop).
- [x] Написать команду, которая останавливает цикл выполнения команд из пункта 1, только после того, как все команды завершат свою работу (soft stop). 
- [x] Написать тесты на команду запуска и остановки потока.

# ДЗ 13. Генерация адаптеров по интерфейсу
Предположим, что у нас есть интерфейс
```
interface Spaceship.Operations.IMovable
{
  Vector getPosition();
  void setPosition(Vector newValue);
  Vector getVelocity();
}
```
1. Необходимо по нему сгенерировать следующий класс:
```
class AutoGenerated.MovableAdapter:  Spaceship.Operations.IMovable
{
  UObject obj;
  public  MovableAdapter(UObject obj)
  {  
     this.obj = obj;
  }

  public Vector getPosition()
  {
     return IoC.Resolve<Vector>("Spaceship.Operations.IMovable:position.get", obj);
  }

  public Vector getVelocity()
  {
     return IoC.Resolve<Vector>("Spaceship.Operations.IMovable:velocity.get", obj);
  }

  public void setPosition(Vector newValue)
  {
     IoC.Resolve<ICommand>("Spaceship.Operations.IMovable:position.set", obj, newValue).Execute();
  }
}
```
так, чтобы можно было создавать экземпляры этого класса.
2. Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
```
var adapter = IoC.Resolve<IMovable>("Adapter", typeof(IMovable), obj);
```
3. Необязательная задача на подумать: если интерфейсе потребуются какие-либо методы, например, как
```
 interface Spaceship.Operations.IMovable
{
  Vector getPosition();
  Vector setPosition(Vector newValue);
  Vector getVelocity();

  void finish();
}
```
Придумать реализацию адаптера для подобных методов.
- [x] Реализован генератор адаптеров
- [x] Реализованы тесты на генератор адаптеров
- [x] Определена стратегия для IoC из п. 2 задания
- [x] Обработан случай из п. 3 задания

# ДЗ 11. Реализация IoC контейнер
В игре Космичекий бой есть набор операций над игровыми объектами: движение по прямой, поворот, выстрел. При этом содержание этих команд может отличаться для разных игр, в зависимости от того, какие правила игры были выбраны пользователями. Например, пользователи могут ограничить запас ход каждого корабля некоторым количеством топлива, а другой игре запретить поворачиваться кораблям по часовой стрелке и т.д.
IoC может помочь в этом случае, скрыв детали в стратегии разрешения зависимости.
Например,
```
IoC.Resolve("двигаться прямо", obj);
```
Возвращает команду, которая чаще всего является макрокомандой и осуществляет один шаг движения по прямой.
Реализовать IoC контейнер, который:
Разрешает зависимости с помощью метода, со следующей сигнатурой:
```
T IoC.Resolve(string key, params object[] args);
```
Указание: Если язык программирования не поддерживает Generics, как, например, PHP, то
1. Запись Вам может быть незнакома. Так оеализуется параметрический полиморфизм в таких языках, как C++, C#, Java, Kotlin и др.
2. Тогда просто возвращайте просто ссылку на базовый класс.
3. Регистрация зависимостей также происходит с помощью метода Resolve
```
IoC.Resolve("IoC.Register", "aaa", (args) => new A()).Execute();
```
4. Зависимости можно регистрировать в разных "скоупах"
```
IoC.Resolve("Scopes.New", "scopeId").Execute();
IoC.Resolve("Scopes.Current", "scopeId").Exceute();
```
Указание: Если Ваш фреймворк допускает работу с многопоточным кодом, то для работы со скоупами используйте ThreadLocal контейнер.
- [x] Интерфейс IoC устойчив к изменению требований.
- [x] IoC предоставляет ровно один метод для всех операций.
- [x] IoC предоставляет работу со скоупами для предотвращения сильной связности.
- [x] Реализованы модульные тесты.
- [x] Реализованы многопоточные тесты.


# ДЗ 9. Макрокоманды
Предположим, что у нас уже написаны команды MoveCommand и RotateCommand. Теперь возникло новое требование: пользователи в игре могут устанавливать правило - во время движение расходуется топливо, двигаться можно только при наличии топлива.
Реализовать новую возможность можно введя две новые команды.
CheckFuelCommand и BurnFuelCommand.
CheckFuelCommand проверяет, что топлива достаточно, если нет, то выбрасывает исключение CommandException.
BurnFuelCommand уменьшает количество топлива на скорость расхода топлива.
После этого мы можем три команды выстроить в цепочку.
CheckFuelCommand MoveCommand BurnFuelCommand
Чтобы это было прозрачно для пользователя реализуем Макрокоманду - специальную разновидность команды, которая в конструкторе принимает массив команда,
а методе execute их все последовательно выполняет.
При повороте движущегося объекта меняется вектор мгновенной скорости. Напишите команду, которая модифицирует вектор мгновенной скорости, в случае поворота.
Постройте цепочку команд для поворота.

- [x] Реализовать класс CheckFuelComamnd и тесты к нему.
- [x] Реализовать класс BurnFuelCommand и тесты к нему.
- [x] Реализовать простейшую макрокоманду и тесты к ней. Здесь простейшая - это значит, что при выбросе исключения вся последовательность команд приостанавливает свое выполнение, а макрокоманда выбрасывает CommandException.
- [x] Реализовать команду движения по прямой с расходом топлива, используя команды с предыдущих шагов.
- [x] Реализовать команду для модификации вектора мгновенной скорости при повороте. Необходимо учесть, что не каждый разворачивающийся объект движется.
- [x] Реализовать команду поворота, которая еще и меняет вектор мгновенной скорости, если есть.

# ДЗ 8. Механизм обработки исключений в игре "Космическая битва"
Предположим, что все команды находятся в некоторой очереди. Обработка очереди заключается в чтении очередной команды и головы очереди и вызова метода Execute извлеченной команды. Метод Execute() может выбросить любое произвольное исключение.

- [x] Обернуть вызов команды в блок `try-catch`.
- [x] Обработчик `catch` должен перехватывать только самое базовое исключение.
- [x] Реализовать множество различных обработчиков исключений. Выбор подходящего обработчика 
должен зависеть от типа перехваченного исключения и команды, которая его выбросила.
- [x] Реализовать команду, которая записывает информацию о выброшенном исключении в лог.
- [x] Реализовать обработчик исключения, который добавляет в очередь команду, записывающую в лог.
- [x] Реализовать команду, которая повторяет команду, выбросившую исключение.
- [x] Реализовать обработчик исключения, который добавляет в очередь команду-повторитель.
- [x] С помощью команд из пунктов выше реализовать обработку исключений: при первом исключении — повторить команду, при втором — записать информацию в лог.
- [x] Реализовать стратегию обработки: повторить два раза, затем записать в лог. Для этого создать отдельную команду, аналогичную пункту 6, тип которой указывает, что команду не удалось выполнить дважды.
