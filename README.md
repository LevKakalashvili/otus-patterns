# ДЗ 13. Генерация адаптеров по интерфейсу
Предположим, что у нас есть интерфейс
```
interface Spaceship.Operations.IMovable
{
  Vector getPosition();
  void setPosition(Vector newValue);
  Vector getVelocity();
}
```
1. Необходимо по нему сгенерировать следующий класс:
```
class AutoGenerated.MovableAdapter:  Spaceship.Operations.IMovable
{
  UObject obj;
  public  MovableAdapter(UObject obj)
  {  
     this.obj = obj;
  }

  public Vector getPosition()
  {
     return IoC.Resolve<Vector>("Spaceship.Operations.IMovable:position.get", obj);
  }

  public Vector getVelocity()
  {
     return IoC.Resolve<Vector>("Spaceship.Operations.IMovable:velocity.get", obj);
  }

  public void setPosition(Vector newValue)
  {
     IoC.Resolve<ICommand>("Spaceship.Operations.IMovable:position.set", obj, newValue).Execute();
  }
}
```
так, чтобы можно было создавать экземпляры этого класса.
2. Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
```
var adapter = IoC.Resolve<IMovable>("Adapter", typeof(IMovable), obj);
```
3. Необязательная задача на подумать: если интерфейсе потребуются какие-либо методы, например, как
```
 interface Spaceship.Operations.IMovable
{
  Vector getPosition();
  Vector setPosition(Vector newValue);
  Vector getVelocity();

  void finish();
}
```
Придумать реализацию адаптера для подобных методов.
- [x] Реализован генератор адаптеров
- [x] Реализованы тесты на генератор адаптеров
- [x] Определена стратегия для IoC из п. 2 задания
- [x] Обработан случай из п. 3 задания

# ДЗ 11. Реализация IoC контейнер
В игре Космичекий бой есть набор операций над игровыми объектами: движение по прямой, поворот, выстрел. При этом содержание этих команд может отличаться для разных игр, в зависимости от того, какие правила игры были выбраны пользователями. Например, пользователи могут ограничить запас ход каждого корабля некоторым количеством топлива, а другой игре запретить поворачиваться кораблям по часовой стрелке и т.д.
IoC может помочь в этом случае, скрыв детали в стратегии разрешения зависимости.
Например,
```
IoC.Resolve("двигаться прямо", obj);
```
Возвращает команду, которая чаще всего является макрокомандой и осуществляет один шаг движения по прямой.
Реализовать IoC контейнер, который:
Разрешает зависимости с помощью метода, со следующей сигнатурой:
```
T IoC.Resolve(string key, params object[] args);
```
Указание: Если язык программирования не поддерживает Generics, как, например, PHP, то
1. Запись Вам может быть незнакома. Так оеализуется параметрический полиморфизм в таких языках, как C++, C#, Java, Kotlin и др.
2. Тогда просто возвращайте просто ссылку на базовый класс.
3. Регистрация зависимостей также происходит с помощью метода Resolve
```
IoC.Resolve("IoC.Register", "aaa", (args) => new A()).Execute();
```
4. Зависимости можно регистрировать в разных "скоупах"
```
IoC.Resolve("Scopes.New", "scopeId").Execute();
IoC.Resolve("Scopes.Current", "scopeId").Exceute();
```
Указание: Если Ваш фреймворк допускает работу с многопоточным кодом, то для работы со скоупами используйте ThreadLocal контейнер.
- [x] Интерфейс IoC устойчив к изменению требований.
- [x] IoC предоставляет ровно один метод для всех операций.
- [x] IoC предоставляет работу со скоупами для предотвращения сильной связности.
- [x] Реализованы модульные тесты.
- [x] Реализованы многопоточные тесты.


# ДЗ 9. Макрокоманды
Предположим, что у нас уже написаны команды MoveCommand и RotateCommand. Теперь возникло новое требование: пользователи в игре могут устанавливать правило - во время движение расходуется топливо, двигаться можно только при наличии топлива.
Реализовать новую возможность можно введя две новые команды.
CheckFuelCommand и BurnFuelCommand.
CheckFuelCommand проверяет, что топлива достаточно, если нет, то выбрасывает исключение CommandException.
BurnFuelCommand уменьшает количество топлива на скорость расхода топлива.
После этого мы можем три команды выстроить в цепочку.
CheckFuelCommand MoveCommand BurnFuelCommand
Чтобы это было прозрачно для пользователя реализуем Макрокоманду - специальную разновидность команды, которая в конструкторе принимает массив команда,
а методе execute их все последовательно выполняет.
При повороте движущегося объекта меняется вектор мгновенной скорости. Напишите команду, которая модифицирует вектор мгновенной скорости, в случае поворота.
Постройте цепочку команд для поворота.

- [x] Реализовать класс CheckFuelComamnd и тесты к нему.
- [x] Реализовать класс BurnFuelCommand и тесты к нему.
- [x] Реализовать простейшую макрокоманду и тесты к ней. Здесь простейшая - это значит, что при выбросе исключения вся последовательность команд приостанавливает свое выполнение, а макрокоманда выбрасывает CommandException.
- [x] Реализовать команду движения по прямой с расходом топлива, используя команды с предыдущих шагов.
- [x] Реализовать команду для модификации вектора мгновенной скорости при повороте. Необходимо учесть, что не каждый разворачивающийся объект движется.
- [x] Реализовать команду поворота, которая еще и меняет вектор мгновенной скорости, если есть.

# ДЗ 8. Механизм обработки исключений в игре "Космическая битва"
Предположим, что все команды находятся в некоторой очереди. Обработка очереди заключается в чтении очередной команды и головы очереди и вызова метода Execute извлеченной команды. Метод Execute() может выбросить любое произвольное исключение.

- [x] Обернуть вызов команды в блок `try-catch`.
- [x] Обработчик `catch` должен перехватывать только самое базовое исключение.
- [x] Реализовать множество различных обработчиков исключений. Выбор подходящего обработчика 
должен зависеть от типа перехваченного исключения и команды, которая его выбросила.
- [x] Реализовать команду, которая записывает информацию о выброшенном исключении в лог.
- [x] Реализовать обработчик исключения, который добавляет в очередь команду, записывающую в лог.
- [x] Реализовать команду, которая повторяет команду, выбросившую исключение.
- [x] Реализовать обработчик исключения, который добавляет в очередь команду-повторитель.
- [x] С помощью команд из пунктов выше реализовать обработку исключений: при первом исключении — повторить команду, при втором — записать информацию в лог.
- [x] Реализовать стратегию обработки: повторить два раза, затем записать в лог. Для этого создать отдельную команду, аналогичную пункту 6, тип которой указывает, что команду не удалось выполнить дважды.
